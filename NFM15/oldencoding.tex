\section{SMT Encoding for MCAPI}
This section summarizes the SMT encoding rules (except the rules for zero buffer semantics) discussed in prior work for MCAPI verification. These rules are used to encode MPI non-deterministic point-to-point communication. In general, the SMT encoding is generated from 1) an execution trace of a program that includes a sequence of events; and 2) a set of possible match pairs for message communication. Intuitively, a match pair is a coupling of a send and a receive. 

%Taking \figref{fig:mpi} as an example, each receive on process \texttt{P0} may be matched with the send at line $l_6$ or the send at line $l_{11}$. The direct use of match pairs simplifies reasoning about message communication. 

The encoding contains a timestamp $\mathit{time}_\mathtt{e}$ for every event $\mathtt{e}$ in a program. Intuitively, the timestamp is an integer.  The event order is enforced by the \emph{Happens-Before} $(\mathtt{HB})$ operator, denoted as
$\mathrm{\prec_\mathtt{HB}}$, over two events, $\mathtt{e1}$ and $\mathtt{e2}$ respectively, such that $\mathit{time}_\mathtt{e1} <  \mathit{time}_\mathtt{e2}$ holds. The send and receive operations are encoded as tuples. In particular, a send operation $\mathtt{S}$ $=$ $(M_\mathtt{S},$ $\mathit{time}_\mathtt{S},$ $e_\mathtt{S},$ $\mathit{value}_\mathtt{S})$, is a four-tuple of variables. $M_\mathtt{S}$ is the timestamp of the matching receive; $\mathit{time}_\mathtt{S}$ is the timestamp of $\mathtt{S}$; $e_\mathtt{S}$ is the destination endpoint; and $\mathit{value}_\mathtt{S}$ is the transmitted value. Similarly, a receive operation $\mathtt{R}$ $=$ $(M_\mathtt{R},$ $\mathit{time}_\mathtt{R},$ $e_\mathtt{R},$ $\mathit{value}_\mathtt{R},$ $\mathit{time}_{\mathtt{W}_\mathtt{R}})$, is modeled by a five-tuple of variables. $M_\mathtt{R}$ is the timestamp of the matching send; $\mathit{time}_\mathtt{R}$ is the timestamp of $\mathtt{R}$; $e_\mathtt{R}$ is the destination endpoint; $\mathit{value}_\mathtt{R}$ is the received value; and $\mathit{time}_{\mathtt{W}_\mathtt{R}}$ is the timestamp of the nearest-enclosing wait ${\mathtt{W}_\mathtt{R}}$. A nearest-enclosing wait is a wait that witnesses the completion of a receive by indicating that the message is delivered and that all the previous receives on the same process issued earlier are completed as well. The message communication topology is encoded as a set of match pairs defined in \defref{def:match}.

\begin{definition}[Match Pair] \label{def:match}
A match pair, $\langle\mathtt{R}, \mathtt{S}\rangle$, for a receive 
$\mathtt{R}$ $=$ $(M_\mathtt{R},$ $\mathit{time}_\mathtt{R},$ $e_\mathtt{R},$ $\mathit{value}_\mathtt{R},$ $\mathit{time}_{\mathtt{W}_\mathtt{R}})$ and a send $\mathtt{S}$ $=$ $(M_\mathtt{S},$ $\mathit{time}_\mathtt{S},$ $e_\mathtt{S},$ $\mathit{value}_\mathtt{S})$, corresponds to the following constraints:
\begin{compactenum}
\item $M_{\mathtt{R}} = \mathit{time}_{\mathtt{S}}$
\item $M_{\mathtt{S}} = \mathit{time}_{\mathtt{R}}$
\item $e_{\mathtt{R}} = e_{\mathtt{S}}$
\item $\mathit{value}_{\mathtt{R}} = \mathit{value}_{\mathtt{S}}$ 
\item $\mathit{time}_{\mathtt{S}}\ \mathrm{\prec_\mathtt{HB}}\ \mathit{time}_{\mathtt{W}_\mathtt{R}}$
\end{compactenum}
\end{definition}

We define the potential sends for a receive $\mathtt{R}$, denoted as $\mathrm{Match}(\mathtt{R})$, as the set of all the sends that $\mathtt{R}$ may potentially match. The encoding rules are given in \figref{fig:ptp}: rules $(1)$ -- $(5)$ encode the program order; rule $(6)$ encodes the match pairs; and rules $(7)$ and $(8)$ encode the assumption on control flow and the negated assertion respectively. Assume a program contains $\mathcal{N}$ API calls, the generated SMT encoding contains $\mathcal{O}(\mathcal{N}^2)$ formulas. The following sections 4 and 5 discuss the new encoding technique for MPI semantics and more importantly zero buffer incompatibility that is not included in the prior work.  

\encodingptp