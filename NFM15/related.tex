\section{Related Works}
The dynamic analyzer ISP implements the POE algorithm, a Dynamic Partial Order Reduction (DPOR) algorithm \cite{DBLP:conf/popl/FlanaganG05} applied to MPI programs \cite{DBLP:conf/ppopp/VakkalankaSGK08}. An extension is the MSPOE algorithm \cite{DBLP:conf/sbmf/SharmaGB12}. It operates by postponing the cooperative operations for message passing in transit until each process reaches a blocking call. It then determines the potential matches of send and receive operations in runtime. In addition to program properties, it is able to check deadlocks.

Forejt et al. proposed a SAT based approach to detect deadlock in a single-path MPI program \cite{DBLP:conf/fm/ForejtKNS14}. This solution is correct and efficient for the programs with low degree of message non-determinism. However, since the size of their encoding is cubic, checking large programs is time consuming. Similar to our solution, this work requires a match pair set that can be over-approximated.

The MPI-Spin is integrated in the classic model checker, SPIN \cite{DBLP:journals/tse/Holzmann97}, for verifying MPI programs \cite{DBLP:conf/vmcai/Siegel07,DBLP:conf/pvm/Siegel07}. It generates a model of an MPI program and allows one to symbolically execute it. As such, violations such as deadlock are detected. It does not scale to large programs with high degree of message non-determinism.

To resolve the scalability problem, Vo et al. use Lamport clocks to update the auxiliary information via piggyback messages \cite{DBLP:conf/sc/VoAGSSB10,DBLP:conf/IEEEpact/VoGKSSB11}. While completeness is abandoned in their analysis, they show this work is useful and efficient in practice. 

The MCC is a model checker that systematically enumerates all message non-determinism in the MCAPI runtime under zero buffer semantics. It employs dynamic partial order reduction to avoid enumerating redundant message orders. This work show SMT technology is more efficient in practice in resolving message non-determinism. 

Elwakil et al. also use SMT techniques to reason about the program behavior in the MCAPI domain \cite{DBLP:conf/issta/ElwakilY10,DBLP:conf/atva/ElwakilYW10}. State-based and order-based encoding techniques are both used. This technique fails to reason about the infinite buffer semantics and requires a precise match set which is non-trivial to compute beforehand.

Our prior work encodes an MCAPI execution into an SMT problem for detecting user-provided assertions \cite{DBLP:conf/kbse/HuangMM13}. The encoding is sound and complete and is easy to reason about infinite buffer semantics without requiring a precise match set. The work also provides an algorithm that runs with quadratic time complexity to generate a sufficiently small over-approximated match set based on the given execution trace. 

There is a rich body of literature for the SMT/SAT based Bounded Model Checking. 
The Threaded-C Bounded Model Checking (TCBMC) extends the C Bounded Model Checking (CBMC) \cite{DBLP:conf/tacas/ClarkeKL04,DBLP:conf/dac/ClarkeKY03} to support concurrent C program verification \cite{DBLP:conf/cav/RabinovitzG05}. It bounds the number of context switches allowed among threads because it assumes that most bug patterns have only a few context switches. Especially, it assumes there is no nested lock-unlock pattern. As discussed earlier, this inspires our approach to encode MPI zero buffer semantics.

Burckhardt et al. present the CheckFence prototype \cite{DBLP:conf/pldi/BurckhardtAM07} that exhaustively checks all executions of a test program by translating a program into SAT formulas. It increments the observations each time by adding more constraints to SAT formulas. 
%Dubrovin et al. give a method to translate an asynchronous system into a transition formula over three partial order semantics \cite{DBLP:journals/scp/DubrovinJH12}. The encoding adds constraints to compress the search space and decrease the bound on the program unwinding.