\section{Experiments}
We launch three series of experiments to test our new encoding: a correctness test on the running examples presented in this paper, a scalability test on the effects of message non-determinism, and a typical benchmark test on several programs. All the results show the comparison between the zero-buffer encoding and the infinite-buffer encoding.  Those experiments were run on a 2.40 GHz Intel Quad Core processor with 8 GB memory running Windows 7. We set a time limit of 2 hours for each test. We abort the verification process if it did not complete within the time-limit. 

The initial program trace is generated by running MPICH \cite{}, a publicly prevalent implementation of MPI standard, with fixed input. The experiments only consider one path of the control flow through the program. Complete coverage of the program for verification purposes would need to generate input to exercise different control flow paths. 

\subsection{Correctness Test}
We evaluate the correctness of our encoding by testing the running examples in \figref{fig:mpi} and \figref{fig:mpi_barrier}. As discussed earlier, these examples, though have few operations, could be very difficult to debug because of the message non-determinism and the barrier synchronization. We test both examples under zero-buffer semantics and infinite-buffer semantics. The results are shown in \tableref{table:correctness}. Each row is the result of a single test with various program environments and performance data. The ``Matches" column represent the number of possible match pair resolutions.  This number over-approximates the message communication in the program. So not all resolutions are allowed by the runtime semantics. As expected, all the results match our discussion earlier. In particular, the execution of the program in \figref{fig:mpi} under infinite-buffering can be violated because of the message non-determinism. However, if zero-buffering is enforced in runtime or the barrier is inserted in a way such as \figref{fig:mpi_barrier}, no violation occurs in any execution of the program. 

\begin{table}[t]
\begin{center}
\scriptsize
\caption{Test on Programs in \figref{fig:mpi} and \figref{fig:mpi_barrier}} \label{table:correctness}
\begin{tabular}{|c|c|c|c|c|c|}
		\hline
         \multicolumn{3}{|c|}{Test Programs} & \multicolumn{3}{|c|}{Performance} \\ \hline
          $Source$&Matches&Buffering&Violation&Time(s)&Memory(MB) \\ \hline
          \figref{fig:mpi} & 2 & 0 & No & 0.03 & 2.19 \\
          	     & 2 & $\infty$ & Yes & 0.13 & 2.18 \\ \hline
          \figref{fig:mpi_barrier} & 2 & 0 & No & 0.03  & 2.19 \\
           & 2 & $\infty$ & No & 0.07 & 2.19 \\
          \hline
		\end{tabular}
\end{center}
\end{table}

As for the performance, all tests return very fast and use low memory because of the small size of messages. However, the performance of larger size of messages is more interesting and essential to our encoding as we can understand how our encoding scales for programs. Therefore, we start the second series of experiments. 

\subsection{Scalability Test}
The scalability of our encoding is affected by the number of messages and the level of non-determinism in choosing match pairs where multiple sends are able to match to multiple receives. This test uses a simple program with one receiver and $\mathit{N}$ senders. $\mathit{N}$ is varied for different tests. In the program, the receiver only issues $\mathit{N}$ wildcard receive operations; each sender only sends a message to the receiver; and the assertion is only violated when each send is matched with a specific receive. This scenario reflects the worst-cast of message non-determinism with $\mathit{N}$ messages, such that any two messages may race in an execution. The results are shown in \tableref{table:scalability}. As the correctness is demonstrated in the prior experiments, this test only put emphasis on the performance comparison. 

\begin{table}[t]
\begin{center}
\scriptsize
\caption{Scalability Test Results}\label{table:scalability}
\begin{tabular}{|c|c|c|c|c|}
		\hline
         \multicolumn{3}{|c|}{Test Programs} & \multicolumn{2}{|c|}{Performance} \\ \hline
          $\mathit{N}$ & Matches & Buffering  & Time(hh:mm:ss) & Memory(MB) \\ \hline
          30 & 30!($\sim$3E32) & 0 & 00:00:01 & 15.17\\
               & & $\infty$ & 00:00:27 & 19.53 \\ \hline
          40 & 40!($\sim$8E47) & 0 & 00:00:08 & 43.81\\
               &  & $\infty$ & 00:03:31 & 48.41 \\ \hline
          50 & 50!($\sim$3E64) & 0 & 00:00:28 & 78.03\\
               & & $\infty$ & 00:12:43 & 91.26\\ \hline
          60 & 60!($\sim$8E81) & 0 & 00:08:13 & 210.82\\
               &  & $\infty$ & 00:36:56 & 174.83\\ \hline
          70 & 70!($\sim$1E100) & 0 & 00:12:02 & 320.49\\
               & & $\infty$ & 01:32:17 & 312.35\\ \hline
          80 & 80!($\sim$2E152) & 0 & 01:33:08 & 728.97\\
               & & $\infty$ & -- & --\\ \hline         
		\end{tabular}
\end{center}
\end{table}
The first comparison is between two buffering settings for each test program. The results are shown as expected. The zero-buffer encoding always return faster than the infinite-buffer encoding. This observation demonstrates that the SMT solver considers less resolutions for the zero-buffer encoding as it is further constrained by our adjustment rules. It is also true for the runtime behavior, because zero-buffer semantics always have less freedom of message communication, thus imply less possible ways to execute the program. 

The results also show the comparison between various message sizes for each buffering setting. The test starts with $30$ messages. The encoding can be resolved fast using low memory, even though the possible choices of match pair resolution is already very large. However, the size of choices is expanded unusually along with the linear increase of message size. With such expansion, the SMT solver has to spend much more time to resolve the encoding. When $\mathit{N}$ increases to 70, the massive size of match resolutions hardly exists in a common MPI program. However, the encoding is still able to scale to it. When $\mathit{N}$ increases to 80, however, the encoding for infinite-buffer semantics is impossible to return within two hours. By running this test, we are able to provide a bound on expected cost for analysis given the message non-determinism in a program. As such, any program with less than 70! possible match resolutions can be reasonably checked by our infinite-buffer encoding. The bound is set to 80! for our zero-buffer encoding.

\subsection{Benchmark Test}
Given the bound on match resolutions, we compare several benchmark programs to test our new encoding. The goal is to further understand how our encoding scales to those programs that are publicly available from a variety of sources:

\begin{compactitem}
\item \textit{Mento Carlo} implements the Mento Carlo method to compute $\pi$ \cite{}. It uses one manger process and three worker processes to send messages back of forth. In addition, it repeatedly uses barrier operations in many places to synchronize the program. 
\item \textit{Router} is an algorithm to update routing tables \cite{} for 50 nodes. Each node is in a ring and communicates only with immediate neighbors to update the tables. The program ends when all the routing tables are updated. This program is unavailable to execute under zero-buffer mainly because each node intends to send two messages before issuing a receive. However, the zero-buffer semantics do not allow the first message to be buffered before sending the second message.
\item \textit{Matmat} implements the matrix multiplication \cite{}. It reads two matrices from the files and output their product. In this program, there are only two processes to communicate messages. The message size is also low.
\item \textit{Integrate} uses heavy non-determinism in message communication to compute an integral of $\sin$ function over the interval $[0, \pi]$ \cite{}. This benchmark also has a manger-worker pattern where the root process divides the interval in a certain number of tasks. It then distributes those tasks to three worker processes. Each worker continues working on a task until it receives a termination message from the manger.
\item \textit{Diffusion 2D} is also from \cite{}. It has an interesting computation pattern that uses barriers to ``partition" the message communication into several sections for four processes. A message from a send can only be delivered to a receive in a common section. 

\end{compactitem}

\begin{table}[t]
\begin{center}
\scriptsize
\caption{Tests on Selected Benchmarks}
\begin{tabular}{|l|c|c|c|c|}
		\hline
         \multicolumn{3}{|c|}{Test Programs} & \multicolumn{2}{|c|}{Performance} \\ \hline
          $Name$&\# Mesg&Buffering&Time(hh:mm:ss)&Memory(MB) \\ \hline
	 \textit{Mento} & 49 & 0 & 00:00:02 & 21.76\\
          \textit{Carlo}    & & $\infty$ & 00:00:02 & 18.08 \\ \hline
	 \textit{Router}   & 200 & 0 & -- & --\\
          	      & & $\infty$ & 00:00:02 & 16.98 \\ \hline
	  \textit{Matmat} & 11 & 0 & $<$00:00:01 & 2.86\\
          	      & &  $\infty$ & $<$00:00:01 & 2.82\\ \hline
	 \textit{Integrate}  & 123 & 0 & 00:00:45 & 135.06 \\
          	      & & $\infty$ & 00:08:07 & 238.68\\ \hline
	  \textit{Diffusion}  & 54 & 0 & 00:00:09 & 44.01 \\
           \textit{2D} &  & $\infty$ & 00:09:15 & 92.08\\ \hline          
          		\end{tabular}
\end{center}
\end{table}


