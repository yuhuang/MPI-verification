\section{Experiments}
We conducted three series of experiments to test our new encoding: a correctness test on the running examples presented in this paper, a scalability test on the effects of message non-determinism, and a typical benchmark test on several programs. All the results show the comparison between the zero-buffer encoding and the infinite-buffer encoding.  Those experiments were run on a 2.40 GHz Intel Quad Core processor with 8 GB memory running Windows 7. We set a time limit of 2 hours for each test. We abort the verification process if it did not complete within the time-limit. 

The initial program trace was generated by running MPICH \cite{mpich}, a publicly prevalent implementation of MPI standard, with fixed input. The experiments only considered one path of the control flow through the program. Complete coverage of the program for verification purposes would need to generate input to exercise different control flow paths. 

\subsection{Correctness Test}
We evaluate the correctness of our encoding by testing the running examples in \figref{fig:mpi} and \figref{fig:mpi_barrier}. As discussed earlier, these examples could be very difficult to debug because of message non-determinism and barrier synchronization. We test both examples under zero-buffer semantics and infinite-buffer semantics. The results are shown in \tableref{table:correctness}. Each row is the result of a single test. The ``Matches" column represent the number of candidate match pair resolutions.  This number over-approximates the number of message communications in the program. As expected, all the results match our discussion earlier. In particular, the execution of the program in \figref{fig:mpi} under infinite buffer semantics can be violated because of message non-determinism. However, if zero buffer semantics are enforced in runtime or the barrier is inserted in a way such as \figref{fig:mpi_barrier}, no violation occurs in any execution of the program. 

\begin{table}[t]
\begin{center}
\scriptsize
\caption{Test on Programs in \figref{fig:mpi} and \figref{fig:mpi_barrier}} \label{table:correctness}
\begin{tabular}{|c|c|c|c|c|c|}
		\hline
         \multicolumn{3}{|c|}{Test Programs} & \multicolumn{3}{|c|}{Performance} \\ \hline
          $Source$&Matches&Buffering&Error&Time(s)&Mem(MB) \\ \hline
          \figref{fig:mpi} & 2 & 0 & No & 0.03 & 2.19 \\
          	     & 2 & $\infty$ & Yes & 0.13 & 2.18 \\ \hline
          \figref{fig:mpi_barrier} & 2 & 0 & No & 0.03  & 2.19 \\
           & 2 & $\infty$ & No & 0.07 & 2.19 \\
          \hline
		\end{tabular}
\end{center}
\end{table}

As for performance, all tests terminate quickly and use little memory because of the small size of the messages in the examples. However, performance with larger messages is more interesting and essential to our encoding as we can understand how our encoding scales for programs. Therefore, we start the second series of experiments. 

\subsection{Scalability Test}
The scalability of our encoding is affected by the number of messages and the level of non-determinism in choosing match pairs where multiple sends are able to match to multiple receives. This test uses a simple program with one receiver and $\mathit{N}$ senders. $\mathit{N}$ is varied for different tests. In the program, the receiver only issues $\mathit{N}$ wildcard receive operations; each sender only sends a message to the receiver; and the assertion is only violated when each send is matched with a specific receive. This scenario reflects the worst-cast of message non-determinism with $\mathit{N}$ messages, such that any two messages may race in an execution. The results are shown in \tableref{table:scalability}. As correctness is demonstrated in the prior experiments, this test only put emphasis on the performance comparison. 

\begin{table}[t]
\begin{center}
\scriptsize
\caption{Scalability Test Results}\label{table:scalability}
\begin{tabular}{|c|c|c|c|c|}
		\hline
         \multicolumn{3}{|c|}{Test Programs} & \multicolumn{2}{|c|}{Performance} \\ \hline
          $\mathit{N}$ & Matches & Buffering  & Time(hh:mm:ss) & Mem(MB) \\ \hline
          30 & 30!($\sim$3E32) & 0 & 00:00:02 & 18.45\\
               & & $\infty$ & 00:00:32 & 19.31 \\ \hline
          40 & 40!($\sim$8E47) & 0 & 00:00:05 & 33.68\\
               &  & $\infty$ & 00:03:08 & 47.12 \\ \hline
          50 & 50!($\sim$3E64) & 0 & 00:00:32 & 75.11\\
               & & $\infty$ & 00:16:06 & 85.68\\ \hline
          60 & 60!($\sim$8E81) & 0 & 00:08:13 & 210.82\\
               &  & $\infty$ & 00:36:56 & 174.83\\ \hline
          70 & 70!($\sim$1E100) & 0 & 00:12:02 & 320.49\\
               & & $\infty$ & 01:32:17 & 312.35\\ \hline
          80 & 80!($\sim$2E152) & 0 & 01:33:08 & 728.97\\
               & & $\infty$ & -- & --\\ \hline         
		\end{tabular}
\end{center}
\end{table}
The first comparison is between two buffering settings for each test program. The results are shown as expected. The zero buffer encoding always return faster than the infinite buffer encoding. This observation demonstrates that the SMT solver considers fewer resolutions for the zero buffer encoding as it is further constrained by our adjustment rules. It is also true for the runtime behavior, because zero buffer semantics always have less freedom of message communication, thus implying fewer possible ways to execute the program. 

The results also show the comparison between various message sizes for each buffering setting. The test starts with $30$ messages. The encoding can be resolved quickly using little memory, even though the number of possible choices for match pair resolutions is already very large. However, the number of choices increases with the factorial of the number of messages. With such expansion, the SMT solver has to spend much more time to resolve the encoding. When $\mathit{N}$ increases to 70, the massive number of match resolutions is much greater than in most common MPI programs. However, the encoding is still able to scale to it. When $\mathit{N}$ increases to 80, however, the MST solver does not return a solution for the infinite buffer encoding within two hours. By running this test, we are able to provide a boundary on expected cost for analysis given the message non-determinism in a program. As such, any program with less than 70! possible match resolutions can be reasonably checked by our infinite-buffer encoding. The boundary is set to 80! for our zero-buffer encoding.

\begin{table*}[t]
\begin{center}
\scriptsize
\caption{Tests on Selected Benchmarks}\label{table:benchmarks}
\begin{tabular}{|l|c|c|c|c|c|c|}
		\hline
         \multicolumn{4}{|c|}{Test Programs} & \multicolumn{3}{|c|}{Performance} \\ \hline
          $Name$&\# Mesg&Matches&Buffering&Error&Time(hh:mm:ss)&Mem(MB) \\ \hline
           \textit{Matmat} & 11 & 1 & 0 & No & $<$00:00:01 & 2.60\\
          	      & & & $\infty$ & No & $<$00:00:01 & 2.58\\ \hline
	 \textit{Mento} & 49 & $\sim$6E27 & 0 & No & 00:00:02 & 21.52\\
          \textit{Carlo}  & & & $\infty$ & No & 00:00:03 & 17.29 \\ \hline
	 \textit{Router}   & 200 & $\sim$6E2 & 0 & -- & -- & --\\
          	      & & & $\infty$ & Yes & 00:00:02 & 17.07 \\ \hline
	 \textit{Integrate}  & 123 & $\sim$1E51 & 0 & No & 00:00:59 & 134.95 \\
          	      & & &  $\infty$ & No & 00:08:23 & 238.68\\ \hline
	  \textit{Diffusion}  & 54 & $\sim$5E57 & 0 & Yes & 00:00:11 & 52.54 \\
           \textit{2D} &  & & $\infty$ & Yes & 00:09:54 & 98.56\\ \hline          
          		\end{tabular}
\end{center}
\end{table*}

\subsection{Benchmark Test}
Given the boundary on match resolutions, we compare several benchmark programs to test our new encoding. The goal is to further understand how our encoding scales to those programs that are publicly available from a variety of sources. The results pertaining to the performance are documented in \tableref{table:benchmarks}. 

\begin{compactitem}

\item \textit{Mento Carlo} implements the Mento Carlo method to compute $\pi$ \cite{benchmark:mentoCarlo}. It uses one manger process and three worker processes to send messages back of forth. In addition, it frequently uses barrier operations in many places to synchronize the program. 
\item \textit{Router} is an algorithm to update routing tables for 50 nodes. Each node is in a ring and communicates only with immediate neighbors to update the tables. The program ends when all the routing tables are updated. 
\item \textit{Matmat} implements matrix multiplication \cite{benchmark:fevs}. It reads two matrices from the files and outputs their product. In this program, there are only two processes to communicate messages. The message size is also low.
\item \textit{Integrate} uses heavy non-determinism in message communication to compute an integral of $\sin$ function over the interval $[0, \pi]$ \cite{benchmark:fevs}. This benchmark also has a manger-worker pattern where the root process divides the interval in a certain number of tasks. It then distributes those tasks to three worker processes. %Each worker continues working on a task until it receives a termination message from the manger.
\item \textit{Diffusion 2D} has an interesting computation pattern that uses barriers to ``partition" the message communication into several sections for four processes \cite{benchmark:fevs}. A message from a send can only be received in a common section. 
\end{compactitem}

As before, we test both buffering settings for each benchmark program. The results show that the zero buffer encoding returns much faster than the infinite buffer encoding for all the benchmark programs. In particular, the test of \textit{Router} demonstrates that it is not compatible with zero buffer semantics. The size of match resolutions is still the primary measure of scalability. \textit{Matmat} is the easiest program to solve. This program has only a single match resolution for an SMT solver to consider thus returns quickly and uses little memory. The programs \textit{Mento Carlo}, \textit{Router}, \textit{Integrate} and \textit{Diffusion 2D} respectively increase the size of match resolutions. For example, even though \textit{Router} has 200 messages, it has less choices on send-receive matches thus returns faster than \textit{Integrate} and \textit{Diffusion 2D}. 

The benchmark suite demonstrates that an MPI program may have a large degree of message non-determinism in runtime. The number of match resolutions is the only deciding factor in scalability of our encoding. For example, even though \textit{Integrate} has more messages than the scalability test with 80 messages, it has less choices for resolving send-receive matches. Therefore, it can be solved with reasonable runtime. As such, the benchmark suite suggests that a program is able to complete in a reasonable amount of time if the number of match resolutions is under the boundary obtained in our scalability test.
